/**
 * category-fortune-card.ts -- 5대 분야별 운세 카드 빌더
 *
 * 5개 분야: wealth(재물/커리어), health(건강), academic(학업),
 *           romance(연애/결혼), family(가족)
 *
 * 분야별 십성 매핑:
 *   - wealth:   재성 (PYEON_JAE, JEONG_JAE) -- 내가 극하는 오행
 *   - health:   인성 (PYEON_IN, JEONG_IN) + 결핍 오행 -- 나를 생하는 오행
 *   - academic: 식상 (SIK_SHIN, SANG_GWAN) + 인성 -- 내가 생하는 + 나를 생하는
 *   - romance:  재성(남) / 관성(여) + 비겁 -- 복합 판단
 *   - family:   인성 + 비겁 -- 나를 생하는 + 같은 오행
 *
 * 연간 운세 기둥이 각 분야의 십성 오행을 얼마나 도와주는지 평가합니다.
 *
 * 모든 텍스트는 ~해요/~에요 체를 사용합니다.
 */

import type { SajuSummary } from '../../types.js';
import type {
  CategoryFortuneCard,
  FortuneCategory,
  StarRating,
  FortuneAdvice,
  FortuneWarning,
} from '../types.js';
import type { ElementCode } from '../types.js';

import {
  getYearlyFortune,
  getFortuneGrade,
} from '../common/fortuneCalculator.js';

import {
  ELEMENT_GENERATES,
  ELEMENT_CONTROLS,
  ELEMENT_GENERATED_BY,
  ELEMENT_CONTROLLED_BY,
  ELEMENT_FOOD,
  ELEMENT_HOBBY,
  ELEMENT_COLOR,
  ELEMENT_DIRECTION,
  ELEMENT_ORGAN,
  ELEMENT_EMOTION,
  ELEMENT_SEASON,
  STEM_BY_CODE,
  BRANCH_BY_CODE,
  getElementRelation,
} from '../common/elementMaps.js';

// ---------------------------------------------------------------------------
//  Element helpers
// ---------------------------------------------------------------------------

const ELEMENT_KO: Record<ElementCode, string> = {
  WOOD: '나무', FIRE: '불', EARTH: '흙', METAL: '쇠', WATER: '물',
};

const STEM_TO_ELEMENT: Record<string, ElementCode> = {
  GAP: 'WOOD', EUL: 'WOOD',
  BYEONG: 'FIRE', JEONG: 'FIRE',
  MU: 'EARTH', GI: 'EARTH',
  GYEONG: 'METAL', SIN: 'METAL',
  IM: 'WATER', GYE: 'WATER',
};

function toElementCode(value: unknown): ElementCode | null {
  if (typeof value !== 'string') return null;
  const upper = value.trim().toUpperCase();
  if (upper in ELEMENT_KO) return upper as ElementCode;
  return STEM_TO_ELEMENT[upper] ?? null;
}

function elementKo(code: ElementCode): string {
  return ELEMENT_KO[code];
}

function gradeToStars(grade: number): StarRating {
  if (grade >= 5) return 5;
  if (grade >= 4) return 4;
  if (grade >= 3) return 3;
  if (grade >= 2) return 2;
  return 1;
}

// ---------------------------------------------------------------------------
//  Category metadata
// ---------------------------------------------------------------------------

const CATEGORY_TITLE: Record<FortuneCategory, string> = {
  wealth: '재물/커리어운',
  health: '건강운',
  academic: '학업운',
  romance: '연애/결혼운',
  family: '가족운',
};

// ---------------------------------------------------------------------------
//  Category element computation
// ---------------------------------------------------------------------------

interface CategoryElements {
  readonly primary: ElementCode;
  readonly secondary: ElementCode | null;
}

function getCategoryElements(
  category: FortuneCategory,
  dayMasterEl: ElementCode,
): CategoryElements {
  switch (category) {
    case 'wealth':
      // 재성: 내가 극하는 오행
      return { primary: ELEMENT_CONTROLS[dayMasterEl], secondary: null };
    case 'health':
      // 인성: 나를 생하는 오행
      return { primary: ELEMENT_GENERATED_BY[dayMasterEl], secondary: null };
    case 'academic':
      // 식상 + 인성: 내가 생하는 + 나를 생하는
      return {
        primary: ELEMENT_GENERATES[dayMasterEl],
        secondary: ELEMENT_GENERATED_BY[dayMasterEl],
      };
    case 'romance':
      // 재성 + 관성: 내가 극하는 + 나를 극하는
      return {
        primary: ELEMENT_CONTROLS[dayMasterEl],
        secondary: ELEMENT_CONTROLLED_BY[dayMasterEl],
      };
    case 'family':
      // 인성 + 비겁: 나를 생하는 + 같은 오행
      return {
        primary: ELEMENT_GENERATED_BY[dayMasterEl],
        secondary: dayMasterEl,
      };
    default:
      return { primary: dayMasterEl, secondary: null };
  }
}

// ---------------------------------------------------------------------------
//  Category grade computation
// ---------------------------------------------------------------------------

/**
 * Compute how well the fortune element supports a category.
 *
 * Logic:
 *   fortune = category primary element -> 5 (directly activates)
 *   fortune generates category element -> 4 (supports it)
 *   fortune is generated by category element -> 3 (neutral exchange)
 *   fortune = category secondary element -> 4 (secondary activation)
 *   fortune controls category element -> 1 (undermines)
 *   else -> 3 (neutral)
 *
 * Then blend with yongshin grade (40%) for overall assessment.
 */
function computeCategoryGrade(
  fortuneEl: ElementCode,
  categoryEls: CategoryElements,
  yongshinGrade: number,
): number {
  let categoryScore: number;

  const relPrimary = getElementRelation(fortuneEl, categoryEls.primary);

  if (relPrimary === 'same') {
    categoryScore = 5;
  } else if (relPrimary === 'generates') {
    categoryScore = 4;
  } else if (relPrimary === 'generated_by') {
    categoryScore = 3;
  } else if (relPrimary === 'controls') {
    categoryScore = 2;
  } else if (relPrimary === 'controlled_by') {
    categoryScore = 1;
  } else {
    categoryScore = 3;
  }

  // If there is a secondary element, average in its score
  if (categoryEls.secondary) {
    let secScore: number;
    const relSec = getElementRelation(fortuneEl, categoryEls.secondary);
    if (relSec === 'same') {
      secScore = 5;
    } else if (relSec === 'generates') {
      secScore = 4;
    } else if (relSec === 'generated_by') {
      secScore = 3;
    } else if (relSec === 'controls') {
      secScore = 2;
    } else if (relSec === 'controlled_by') {
      secScore = 1;
    } else {
      secScore = 3;
    }
    categoryScore = (categoryScore + secScore) / 2;
  }

  // Blend: 60% category-specific, 40% yongshin
  return categoryScore * 0.6 + yongshinGrade * 0.4;
}

// ---------------------------------------------------------------------------
//  Summary generators
// ---------------------------------------------------------------------------

function makeCategorySummary(
  category: FortuneCategory,
  stars: StarRating,
  fortuneEl: ElementCode,
  catEls: CategoryElements,
): string {
  const fortuneKo = elementKo(fortuneEl);
  const catKo = elementKo(catEls.primary);
  const title = CATEGORY_TITLE[category];
  const sameElement = fortuneEl === catEls.primary;

  const GOOD_SUFFIX: Record<FortuneCategory, string> = {
    wealth: '재물 흐름이 원활해져요.',
    health: '체력과 회복력이 안정적이에요.',
    academic: '학습 효율이 올라가는 시기예요.',
    romance: '인연의 흐름이 좋아져요.',
    family: '가정의 분위기가 따뜻해져요.',
  };

  if (stars >= 5) {
    const support = sameElement
      ? `${fortuneKo} 기운이 직접 활성화되어`
      : `${fortuneKo} 기운이 ${catKo} 기운을 크게 도와줘서`;
    return `올해 ${title}은 최고예요! ${support} ${GOOD_SUFFIX[category]}`;
  }
  if (stars >= 4) {
    const support = sameElement
      ? `${fortuneKo} 기운이 직접 흘러들어`
      : `${fortuneKo} 기운이 ${catKo} 기운을 받쳐줘서`;
    return `올해 ${title}은 좋은 편이에요. ${support} ${GOOD_SUFFIX[category]}`;
  }
  if (stars >= 3) {
    return `올해 ${title}은 보통이에요. 큰 변화보다는 기본을 지키며 꾸준히 관리하면 좋아요.`;
  }
  if (stars >= 2) {
    return `올해 ${title}은 다소 주의가 필요해요. 무리한 확장보다 안정적인 관리에 집중하세요.`;
  }
  return `올해 ${title}은 쉽지 않은 흐름이에요. 무리하지 말고 기본을 잘 지키며 꾸준히 관리하는 것이 중요해요.`;
}

// ---------------------------------------------------------------------------
//  Advice generators per category
// ---------------------------------------------------------------------------

function makeWealthAdvice(stars: StarRating, fortuneEl: ElementCode, catEl: ElementCode): FortuneAdvice[] {
  const advice: FortuneAdvice[] = [];
  const foods = ELEMENT_FOOD[catEl] ?? [];
  const color = ELEMENT_COLOR[catEl] ?? '';
  const direction = ELEMENT_DIRECTION[catEl] ?? '';

  if (stars >= 4) {
    advice.push({
      text: '새로운 투자나 사업 기회를 검토해 보기 좋은 시기예요.',
      reason: '재성 기운이 잘 흐르고 있어서 재물 관련 행동이 좋은 결과로 이어지기 쉬워요.',
    });
    advice.push({
      text: `${color} 계열의 지갑이나 소품이 재물운을 도와줄 수 있어요.`,
      reason: `재성 오행(${elementKo(catEl)})의 색을 활용하면 기운이 자연스럽게 강화돼요.`,
    });
  } else {
    advice.push({
      text: '큰 지출이나 투자는 신중하게, 가능하면 전문가 상담 후 결정하세요.',
      reason: '재성 기운이 약한 시기에는 보수적인 재무 전략이 안전해요.',
    });
    advice.push({
      text: '불필요한 지출을 줄이고 저축 비율을 조금씩 높여보세요.',
      reason: '재물 기운이 약할 때 아끼는 습관이 나중에 큰 도움이 돼요.',
    });
  }

  return advice;
}

function makeHealthAdvice(
  stars: StarRating,
  fortuneEl: ElementCode,
  dayMasterEl: ElementCode,
  deficients: ElementCode[],
  gishinEl: ElementCode | null,
  yongshinEl: ElementCode,
): FortuneAdvice[] {
  const advice: FortuneAdvice[] = [];
  const resourceEl = ELEMENT_GENERATED_BY[dayMasterEl];
  const organ = ELEMENT_ORGAN[resourceEl];

  if (stars >= 4) {
    advice.push({
      text: '건강 기운이 안정적이에요. 꾸준한 운동 루틴을 유지하면 더욱 좋아요.',
      reason: '인성 기운이 잘 흐르면 회복력과 면역력이 좋아지는 시기예요.',
    });
  } else {
    advice.push({
      text: `${organ?.detail ?? '관련 장기'}에 특히 신경 쓰고, 정기 검진을 받아보세요.`,
      reason: '인성 기운이 약하면 나를 보호하는 힘이 줄어들어 건강 관리가 더 중요해요.',
    });
  }

  if (deficients.length > 0) {
    const weakEl = deficients[0];
    const foods = ELEMENT_FOOD[weakEl] ?? [];
    advice.push({
      text: foods.length > 0
        ? `${elementKo(weakEl)} 기운 보충을 위해 ${foods.slice(0, 3).join(', ')} 같은 음식을 챙기세요.`
        : `${elementKo(weakEl)} 기운이 약하니 관련 건강 관리를 신경 써주세요.`,
      reason: `부족한 ${elementKo(weakEl)} 기운을 채우면 전체 건강 균형이 좋아져요.`,
    });
  }

  // Recommend activities: prefer yongshin hobbies if resource element matches gishin
  const activityEl = (resourceEl === gishinEl) ? yongshinEl : resourceEl;
  const hobbies = ELEMENT_HOBBY[activityEl] ?? [];
  if (hobbies.length > 0) {
    const elLabel = (resourceEl === gishinEl)
      ? `용신(${elementKo(yongshinEl)})`
      : `인성(${elementKo(resourceEl)})`;
    advice.push({
      text: `${hobbies.slice(0, 2).join(', ')} 같은 활동이 건강 기운을 보강해 줘요.`,
      reason: `${elLabel} 기운과 어울리는 활동이 몸과 마음을 함께 케어해요.`,
    });
  }

  return advice.slice(0, 3);
}

function makeAcademicAdvice(stars: StarRating, dayMasterEl: ElementCode): FortuneAdvice[] {
  const advice: FortuneAdvice[] = [];
  const outputEl = ELEMENT_GENERATES[dayMasterEl]; // 식상
  const resourceEl = ELEMENT_GENERATED_BY[dayMasterEl]; // 인성

  if (stars >= 4) {
    advice.push({
      text: '학습 효율이 높은 시기예요. 새로운 분야에 도전하거나 자격증 준비를 시작해 보세요.',
      reason: '식상과 인성 기운이 좋으면 이해력과 표현력이 함께 올라가요.',
    });
    advice.push({
      text: '배운 내용을 다른 사람에게 설명하거나 정리 노트를 만들면 실력이 빠르게 올라요.',
      reason: `${elementKo(outputEl)} 기운(식상)이 좋을 때 아웃풋 학습이 특히 효과적이에요.`,
    });
  } else {
    advice.push({
      text: '기본기 복습에 집중하고, 난이도 높은 과제는 단계적으로 접근하세요.',
      reason: '학업 기운이 약할 때는 욕심보다 기초 다지기가 더 효율적이에요.',
    });
    advice.push({
      text: '혼자 끙끙대기보다 스터디 그룹이나 멘토의 도움을 받으면 효과가 커요.',
      reason: `${elementKo(resourceEl)} 기운(인성)이 약할 때 외부 도움이 학습 속도를 높여줘요.`,
    });
  }

  return advice;
}

function makeRomanceAdvice(stars: StarRating, dayMasterEl: ElementCode): FortuneAdvice[] {
  const advice: FortuneAdvice[] = [];
  const wealthEl = ELEMENT_CONTROLS[dayMasterEl]; // 재성
  const authorityEl = ELEMENT_CONTROLLED_BY[dayMasterEl]; // 관성
  const color = ELEMENT_COLOR[wealthEl] ?? '';

  if (stars >= 4) {
    advice.push({
      text: '새로운 만남이나 인연이 자연스럽게 들어오기 좋은 시기예요. 모임에 적극 참여해 보세요.',
      reason: '재성/관성 기운이 잘 흘러 대인 매력과 인연 운이 높아져 있어요.',
    });
    advice.push({
      text: `${color} 계열의 옷이나 액세서리가 만남 운을 도와줄 수 있어요.`,
      reason: `인연과 관련된 오행(${elementKo(wealthEl)})의 색을 활용하면 매력이 자연스럽게 올라가요.`,
    });
  } else {
    advice.push({
      text: '지금은 새 관계를 서두르기보다 기존 관계를 깊게 가꾸는 데 집중하세요.',
      reason: '연애 기운이 약한 시기에 무리하면 오히려 관계가 꼬이기 쉬워요.',
    });
    advice.push({
      text: '상대방의 말을 먼저 경청하고, 감정적 반응을 한 박자 늦추는 연습을 해보세요.',
      reason: '관성 기운이 약할 때 소통 방식을 보완하면 관계 안정성이 높아져요.',
    });
  }

  return advice;
}

function makeFamilyAdvice(stars: StarRating, dayMasterEl: ElementCode): FortuneAdvice[] {
  const advice: FortuneAdvice[] = [];
  const resourceEl = ELEMENT_GENERATED_BY[dayMasterEl]; // 인성
  const emotion = ELEMENT_EMOTION[dayMasterEl];

  if (stars >= 4) {
    advice.push({
      text: '가족과의 소통이 자연스럽게 잘 되는 시기예요. 함께하는 시간을 의도적으로 만들어 보세요.',
      reason: '인성과 비겁 기운이 좋으면 가족 간 유대와 지지가 강해져요.',
    });
    advice.push({
      text: '감사 표현과 작은 선물이 관계를 더 따뜻하게 만들어 줘요.',
      reason: '좋은 기운이 흐를 때 표현하면 효과가 배로 커져요.',
    });
  } else {
    advice.push({
      text: '가족과 의견 차이가 생길 수 있어요. 충고보다 공감을 먼저 전하세요.',
      reason: '비겁 기운이 약하면 가까운 사이에서 마찰이 생기기 쉬워요.',
    });
    if (emotion) {
      advice.push({
        text: `${emotion.negative}이 올라올 때 바로 말하기보다 잠시 호흡을 고르세요.`,
        reason: '감정이 격해질 때 한 박자 쉬면 불필요한 충돌을 막을 수 있어요.',
      });
    }
  }

  return advice;
}

// ---------------------------------------------------------------------------
//  Caution generator
// ---------------------------------------------------------------------------

function makeCaution(
  category: FortuneCategory,
  stars: StarRating,
  fortuneEl: ElementCode,
  catEls: CategoryElements,
): FortuneWarning | null {
  // Only generate caution for low scores
  if (stars >= 4) return null;

  const catKo = elementKo(catEls.primary);
  const fortuneKo = elementKo(fortuneEl);

  const cautionMap: Record<FortuneCategory, FortuneWarning> = {
    wealth: {
      signal: `올해 재물 기운이 ${fortuneKo} 기운과 긴장 관계에 있어요.`,
      response: '큰 투자나 보증은 피하고, 지출 상한선을 미리 정해두세요.',
      reason: `${fortuneKo} 기운이 ${catKo} 기운(재성)을 방해하여 재물 손실 위험이 있어요.`,
    },
    health: {
      signal: '건강 기운이 약해서 컨디션 관리에 주의가 필요해요.',
      response: '과로를 피하고, 정기 검진을 받아보세요. 수면 리듬을 반드시 지켜주세요.',
      reason: '인성 기운이 약하면 회복력이 떨어져서 작은 피로도 쌓이기 쉬워요.',
    },
    academic: {
      signal: '학업 집중력이 흔들리기 쉬운 시기예요.',
      response: '공부 시간을 짧게 나누고, 어려운 부분은 질문하거나 멘토의 도움을 받으세요.',
      reason: '식상과 인성 기운이 약하면 이해와 표현 모두 효율이 떨어질 수 있어요.',
    },
    romance: {
      signal: '관계에서 오해나 감정 소모가 생기기 쉬운 시기예요.',
      response: '새 관계를 서두르지 말고, 기존 관계에서 소통 방식을 점검해 보세요.',
      reason: '재성/관성 기운이 약하면 인연의 타이밍이 맞지 않을 수 있어요.',
    },
    family: {
      signal: '가족 사이에 작은 마찰이 생기기 쉬운 시기예요.',
      response: '충고보다 경청을 우선하고, 감정이 올라오면 잠시 자리를 비우세요.',
      reason: '비겁과 인성 기운이 약하면 가까운 사이에서 오히려 갈등이 커질 수 있어요.',
    },
  };

  return cautionMap[category] ?? null;
}

// ---------------------------------------------------------------------------
//  Main builder
// ---------------------------------------------------------------------------

export function buildCategoryFortuneCards(
  saju: SajuSummary,
  targetDate: Date,
): Record<FortuneCategory, CategoryFortuneCard> {
  // Extract natal data
  const dayMasterElement = toElementCode(saju.dayMaster?.element) ?? 'EARTH';
  const yongshinElement = toElementCode(saju.yongshin?.element) ?? 'WATER';
  const heeshinElement = toElementCode(saju.yongshin?.heeshin);
  const gishinElement = toElementCode(saju.yongshin?.gishin);

  const deficientElements: ElementCode[] = [];
  if (Array.isArray(saju.deficientElements)) {
    for (const raw of saju.deficientElements) {
      const el = toElementCode(raw);
      if (el) deficientElements.push(el);
    }
  }

  // Get yearly fortune pillar
  const year = targetDate.getFullYear();

  // Try saeunPillars first
  let fortuneEl: ElementCode = 'EARTH';

  const saeunPillars = (saju as Record<string, unknown>).saeunPillars as
    | Array<{ year: number; stem: string; branch: string }>
    | undefined;
  if (Array.isArray(saeunPillars)) {
    const match = saeunPillars.find((p) => p.year === year);
    if (match) {
      const stemEl = toElementCode(match.stem);
      if (stemEl) fortuneEl = stemEl;
    }
  }

  if (fortuneEl === 'EARTH' && !saeunPillars) {
    // Fallback: compute from formula
    const yf = getYearlyFortune(year);
    fortuneEl = yf.stemElement;
  }

  // Yongshin grade for the year
  const yongshinGrade = getFortuneGrade(fortuneEl, yongshinElement, heeshinElement, gishinElement);

  const CATEGORIES: FortuneCategory[] = ['wealth', 'health', 'academic', 'romance', 'family'];

  const result = {} as Record<FortuneCategory, CategoryFortuneCard>;

  for (const category of CATEGORIES) {
    const catEls = getCategoryElements(category, dayMasterElement);
    const grade = computeCategoryGrade(fortuneEl, catEls, yongshinGrade);
    const stars = gradeToStars(Math.round(grade));

    const summary = makeCategorySummary(category, stars, fortuneEl, catEls);

    // Generate category-specific advice
    let advice: FortuneAdvice[];
    switch (category) {
      case 'wealth':
        advice = makeWealthAdvice(stars, fortuneEl, catEls.primary);
        break;
      case 'health':
        advice = makeHealthAdvice(stars, fortuneEl, dayMasterElement, deficientElements, gishinElement, yongshinElement);
        break;
      case 'academic':
        advice = makeAcademicAdvice(stars, dayMasterElement);
        break;
      case 'romance':
        advice = makeRomanceAdvice(stars, dayMasterElement);
        break;
      case 'family':
        advice = makeFamilyAdvice(stars, dayMasterElement);
        break;
      default:
        advice = [];
    }

    const caution = makeCaution(category, stars, fortuneEl, catEls);

    result[category] = {
      title: CATEGORY_TITLE[category],
      category,
      stars,
      summary,
      advice,
      caution,
    };
  }

  return result;
}
